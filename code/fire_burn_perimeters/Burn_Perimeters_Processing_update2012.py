# ---------------------------------------------------------------------------
#
# Summary : This script uses the wildfire perimeter data accessed here:
#           http://frap.fire.ca.gov/data/frapgisdata/select.asp
#           to split the data into yearly events, and accumulate
#           totals for each year (based on previous years).
#
#           Want to calculate:
#               Number of years Burned for a given location
#               Years since last fire
#               Year of Last Burn
#
#           A new layer is created for each year with the abouve variables
#           added.  For fires between 1900 - 2006, this routines takes
#           about 4.5 hours to run.
#
# Author  : Dave Waetjen
# Created : April 14 2008
#
# Notes   : This script was built from a mish mash of examples, including
#           scripts that were auto-generated by ArcGIS/ModelBuilder, and
#           other scripts supplied by Josh Viers of ICE.
#
# Changes made by Aaron King (amking@ucdavis.edu):
#   Set inpath variable different from shppath
#   Added a few steps in the main loop that create a fire name field for each
#    year, then populate it.
#   Added steps after the current year export to eliminate overlapping polygons
#    (union, addfield, dissolve) created when fire perimeters from the same year
#    overlap.
#   Added a label field to each yearly unioned output that is populated with
#    the most recent fire name.
#   Added a CFRI field to each yearly unioned output that is populated with the
#    Current Fire Return Interval based on the equation
#    (years of record)/(number of burns +1)
#   Added GUI arguments so the script can be run fom ARC Map with user inputs
#   Added the variable backdate_year in order to calculate CFRI correctly.

# Changes made my Nick Santos (nrsantos@ucdavis.edu) on 4/26/2012:
# 	Updated to arcpy (ArcGIS 10)
# 	Small tweaks to the cleanup code for future maintainability


# PREP THE INPUT DATA:
#   Should have no nulls or missing values in the YEAR_ field
#   Replace all nulls and missing values with 99
#   Inspection of the containment dates or other notes in the data
#   may allow to fill in correct date
#   No quotes (" or ') should be present in the FIRE_NAME attribute
#
# GUI:
#   Assumes that the input burn perimeters data is a shapefile, as it should be.
#   Assumes the output will be in a file geodatabase, as it should be.
#
#---------------------------------------------------------------------------


# Import system modules
import sys, string, os

# Create the Geoprocessor object
try:
    import arcpy
except:
    print 'unable to import arcpy, exiting...'
    sys.exit(0)

from time import *


# Overwrite layers if present (1 = overwrite, 0 = do not overwrite)
arcpy.env.overwriteOutput = 1

# ----------------------------------------------------------------------------
# ** CHANGE THESE VARIABLES AS NEEDED
# ----------------------------------------------------------------------------
# Input / Output Locations and Set the necessary product code

input_fire_data = sys.argv[1] # "E:/calfire/fire_perims_2008/ALLFIRES_08.shp"
if not arcpy.Exists(input_fire_data):
    print 'fire input data do not exist'
    sys.exit(0)
output_data = sys.argv[2]  #"E:/calfire/test.gdb"

# if Geodatabase, set this value to 0, otherwise 1
is_output_shapefile = 0
# is_input_shapefile handled about 20 lines down from here. It's done automatically now

# Script Debugging -- show progress messages to standard output
debug = 0
# Reinitialize every how many years:
gpreinit = 25

# Set Minimum and Maximum Years to process
minimum_year = int(sys.argv[3])
maximum_year = int(sys.argv[4]) + 1
# the way this works, it does not process the maximum year selected, so we add
# a year to the user-selected maximum


# These variables allow for start in the middle of the processing period
# provided you have the previous year's union file fyYYYYu.shp
# 0 = start from beginning, 1 = start at continue_year
start_midway = 0
continue_year = 2000

# this should be the first year you processed in the original run, before it crashed
if (start_midway): backdate_year = 1908
else: backdate_year = minimum_year


# check whether we passed in a shapefile or a feature class (rest of code assumes feature class). These should actually be True/False settings, but that would require more refactorying (NS 4/26/2012)
desc = arcpy.Describe(input_fire_data) # get info about the input
if desc.dataType == "ShapeFile": # if arcpy reports that it's a shapefile
	is_input_shapefile = 1 # set the flag
else:
	is_input_shapefile = 0 # otherwise, set the flag to 0
del desc # close the describe object

# ----------------------------------------------------------------------------



# ----------------------------------------------------------------------------
#  Make directory
# ----------------------------------------------------------------------------
def _mkdir(newdir):
    """works the way a good mkdir should :)
        - already exists, silently complete
        - regular file in the way, raise an exception
        - parent directory(ies) does not exist, make them as well
    """
    if (debug): print "creating directory: " + newdir
    if os.path.isdir(newdir):
        pass
    elif os.path.isfile(newdir):
        raise OSError("a file with the same name as the desired " \
                      "dir, '%s', already exists." % newdir)
    else:
        head, tail = os.path.split(newdir)
        if head and not os.path.isdir(head):
            _mkdir(head)
        #print "_mkdir %s" % repr(newdir)
        if tail:
            os.mkdir(newdir)


# ----------------------------------------------------------------------------
#  Get Min Value
# ----------------------------------------------------------------------------
def get_min_year(datasrc):
    print 'sourcing minimum year'
    try:
        rows = arcpy.SearchCursor(datasrc)
    except:
        print 'unable to create searchcursor'
        sys.exit(0)
    try:
        row = rows.next()
    except:
        print 'unable to create searchcursor'
        sys.exit(0)
    minval = 3000
    cnt = 0
    try:
        while row:
#            if (debug):
#                cnt += 1
#                if cnt < 10:
#                    print "Name: %s, Year: %s, GIS Acres: %i" % (row.FIRE_LABEL, row.YEAR_, row.GIS_ACRES)
            if ((minval > int(row.YEAR_)) and (int(row.YEAR_) >= minimum_year)):
                minval = int(row.YEAR_)
                if debug:
                    print minval
            row = rows.next()
        print 'finished minimum year loop'

    except:
        print "Error getting minimum year"
        arcpy.AddMessage("Error getting minimum year")
        sys.exit(0)
    if (debug): print "Minimum Year is: %i" % (minval)
    del row, rows
    return minval

# ----------------------------------------------------------------------------
#  Get Max Value
# ----------------------------------------------------------------------------
def get_max_year(datasrc):
    print 'sourcing maximum year'

    try:
        rows = arcpy.SearchCursor(datasrc)
        row = rows.next()
        maxval = 1
        while row:
            if ((maxval < int(row.YEAR_)) and (int(row.YEAR_) <= maximum_year)):
                maxval = int(row.YEAR_)
            row = rows.next()

        if (debug): print "Maximum Year is: %i" % (maxval)
        del row, rows
        return maxval
    except:
        print "Error getting maximum year"
        arcpy.AddMessage("Error getting maximum year")
        sys.exit(0)

# ----------------------------------------------------------------------------
#  is it a fire year?
# ----------------------------------------------------------------------------
def is_fire_year(datasrc, test_year):

    try:
        rows = arcpy.SearchCursor(datasrc)
        row = rows.next()
        found = 0
        while row:
            if  (test_year == int(row.YEAR_)):
                found = 1
                break
            row = rows.next()

        del row, rows
        return found
    except:
        print "Error determining fire year"
        arcpy.AddMessage("Error determining fire year")
        sys.exit(0)

# ----------------------------------------------------------------------------
#  Export to Shapefile
#    input_layer: layer to be exported (with selection in place)
#    output_layer: stub for new layer, which includes location
# ----------------------------------------------------------------------------
def export_shapefile(input_layer, output_layer):
    try:
        arcpy.CopyFeatures_management(input_layer, output_layer)
        if (debug): print "finished copyfeatures: " + input_layer + "to " + output_layer
    except:
        print "Error CopyFeatures: " + output_layer
        arcpy.AddMessage("Error CopyFeatures")
        sys.exit(0)

# ----------------------------------------------------------------------------
#  Create Temporary Fire Year Layer by selecting all fires for current year
# ----------------------------------------------------------------------------
def get_temp_fire_year(feature_layer_fires, current_year):

    try:
        if (is_input_shapefile): #THESE LOOK REVERSED TO ME, BUT IT WORKS...SO OK
            sql = ' "YEAR_" = \'' + str(current_year) + "' "
        else:
            sql = ' [YEAR_] = \'' + str(current_year) + "' "

        arcpy.SelectLayerByAttribute_management(feature_layer_fires, "NEW_SELECTION", sql)
        if (debug): print "finished SelectLayerByAttribute: " + feature_layer_fires + sql
        fire_year = "sfy" + str(current_year)
        if arcpy.Exists(fire_year):
            arcpy.Delete_management(fire_year)
    except:
        print "Error in the SelectLayerByAttribute step"
        arcpy.AddMessage("Error in the SelectLayerByAttribute step")
        sys.exit(0)

    export_shapefile(feature_layer_fires, fire_year)
    return fire_year
# ----------------------------------------------------------------------------
#  Union on the current year single file
# ----------------------------------------------------------------------------
def union_single(datasrc, current_year):
    try:

        if (is_output_shapefile):
                union_input = datasrc + ".shp"
        else:
                union_input = datasrc
        sfyu = datasrc + "u"
# HAD TO INTRODUCE A WHOLE NEW SET OF TEMPORARY FILES, ALL START WITH "sf".  THESE
# DEAL WITH THE ISSUE OF POLYGONS FROM A SINGLE YEAR OVERLAPPING
        if (debug): print "Processing Single Year Union: " + union_input
        arcpy.Union_analysis(union_input, sfyu, "NO_FID", "1 meter", "GAPS")
        return sfyu

    except:
        arcpy.AddMessage('First Union failure: ' + sfyu)
        sys.exit(0)
# ----------------------------------------------------------------------------
#LIST FIELDS: Lists fields and field properties for inputValue
# ----------------------------------------------------------------------------
def list_fields(inputValue, wildCard, fieldType):
##        '"""Lists fields (and selected properties) for inputValue"""
    if arcpy.Exists(inputValue) == 1:
        fieldList = arcpy.ListFields(inputValue, wildCard, fieldType)
        field = fieldList.next()
#FORMATTING INFO: NAME = 50 spaces, TYPE = 15 spaces, LENGTH = 15 spaces, SCALE = 15 spaces, PRECISION = 15 spaces
        print "NAME                                              " + "TYPE           " + "LENGTH         " + "SCALE          " + "PRECISION      "
        print "-" * 100
        while field:
            try:
                print str(field.name)[0:50] + " "*(50-len(field.name)) \
                      + str(field.type)[0:15] + " "*(15-len(str(field.type))) \
                      + str(field.length)[0:15] + " "*(15-len(str(field.length))) \
                      + str(field.scale)[0:15] + " "*(15-len(str(field.scale))) \
                      + str(field.precision)[0:15] + " "*(15-len(str(field.precision)))
            except:
                print "ERROR: CAN'T ACCESS INFORMATION FOR " + field + "!"
            field = fieldList.next()
        return 1
    else:
         print "ERROR: " + inputValue + " does not exist!"
         return 0

# ----------------------------------------------------------------------------
#  Update the shape_area field
# ----------------------------------------------------------------------------
def calc_shape_area(calc_input):
    if (debug): print "calculating FIRE_AREA"
    try:
        aExpression = "float(!shape.area@squaremeters!)"
        print aExpression
##        print calc_input
##        print "ShapeFieldName: \n" + str(arcpy.describe(calc_input).ShapeFieldName)
##        if ok:
##            print "listed fields"
##        else:
##            print "did not list fields"
    except:
        print 'fail aExpression in calc_shape_area'
    try:
        arcpy.CalculateField_management(calc_input,"FIRE_AREA",aExpression,"PYTHON")
    except:
        print "'Calc. FIRE_AREA failure: ' + calc_input"
        arcpy.AddMessage('Calc. FIRE_AREA failure: ' + calc_input)
        sys.exit(0)
# ----------------------------------------------------------------------------
#  Dissolve the single fire year file on the SHAPE_AREA field and retain the year and label.
#  The label retained is the last one read by the code as it processes overlapping polygons.
#  This was arbitrary.
# ----------------------------------------------------------------------------
def dissolve_single(dissolve_input, current_year):
    try:
        if (is_output_shapefile):
            sfyd = "sfy" + str(current_year) +"d.shp"
        else:
            sfyd = "sfy" + str(current_year) +"d"

        arcpy.Dissolve_management(dissolve_input, sfyd, "FIRE_AREA", "FIRE_LABEL LAST", "SINGLE_PART")
        return sfyd
    except:
        arcpy.AddMessage("Dissolve Single Year failure: " + sfyd)
        sys.exit(0)

# ----------------------------------------------------------------------------
#  Setup Environement
# ----------------------------------------------------------------------------
def setup_environment():
    try:
# Setup Workspace
# _mkdir(output_data) #temp exclusion
        arcpy.env.workspace = output_data
        arcpy.env.scratchWorkspace = output_data
#       arcpy.XYResolution = "0.1"
#       arcpy.XYTolerance = "5"
        if (debug): print "Workspace: " + (arcpy.env.workspace)
        if (debug): print "Fire Data: %s" % (input_fire_data)

# make a feature layer from shapefile for processing
        fl_fires = "allfires"
        if not arcpy.Exists(fl_fires):
            arcpy.MakeFeatureLayer_management(input_fire_data, fl_fires)
            print 'created Feature Layer of allfires'

        return fl_fires
    except:
        print "Error setting up environment"
        arcpy.AddMessage("Error Setting up Environment")
        sys.exit(0)

# ----------------------------------------------------------------------------
#  Repair Geometry
# ----------------------------------------------------------------------------
def repair_geometry(datasrc):
    try:
        if (is_output_shapefile):
            datasource = datasrc + ".shp"
        else:
            datasource = datasrc

        if (debug): print "Repairing Geometry: " + datasource
        arcpy.RepairGeometry_management(datasource)
    except:
        print "Unable to Repair Geometry: " + datasrc
        arcpy.AddMessage("Unable to Repair Geometry: " + datasrc)
        sys.exit(0)

# ----------------------------------------------------------------------------
#  Add field to datasource given fieldname and data type
# ----------------------------------------------------------------------------
def add_field(datasrc, fieldname, type):
    try:
        if (is_output_shapefile):
            datasource = datasrc + ".shp"
        else:
            datasource = datasrc
        if (debug): print "Adding Field: " + fieldname + " to " + datasource
        arcpy.AddField_management(datasource, fieldname, type)

    except:
        print "Add field failure: " + fieldname + " to " + datasource
        arcpy.AddMessage("Add field failure: " + fieldname + " to " + datasource)
        sys.exit(0)

# ----------------------------------------------------------------------------
#  Use CalculateField to fill in yearly values
# ----------------------------------------------------------------------------
def fill_field(datasrc, fieldname, filling, codetype):
    try:
        if (is_output_shapefile):
            datasource = datasrc + ".shp"
        else:
            datasource = datasrc

        if (debug): print "Calculating Field: " + fieldname + " in " + datasource

        arcpy.CalculateField_management(datasource, fieldname, filling, codetype, "")

    except:
        print 'fill_Field failure: ' + datasource
        arcpy.AddMessage('fill_Field failure: ' + datasource)
        sys.exit(0)

# ----------------------------------------------------------------------------
#  Dissolve datasource based on fieldname
#  Dissolves the whole new shapefile into one feature based on yr####
# ----------------------------------------------------------------------------
def dissolve_layer(datasrc, disfields):
    # print disfields
    try:
        if (is_output_shapefile):
            fyd = datasrc + "d.shp"
            datasource = datasrc + ".shp"
        else:
            fyd = datasrc + "d"
            datasource = datasrc

        if (debug): print "Dissolving Year: " + fyd
        arcpy.Dissolve_management(datasource, fyd, disfields, "", "SINGLE_PART")
        return (datasrc + "d")

    except:
        print 'Dissolve failure: ' + fyd
        arcpy.AddMessage('Dissolve failure: ' + fyd)
        sys.exit(0)

# ----------------------------------------------------------------------------
#  Union fires from previous years
#  Note: this routine handles the naming of the layer names to union
# ----------------------------------------------------------------------------
def union_fires(current_year, previous_year, first_pass):
    try:
        if (first_pass):
            if (is_output_shapefile):
                shp_union = "sfy" + str(current_year) + "dd.shp"
            else:
                shp_union = "sfy" + str(current_year) + "dd"
        else:
            if (is_output_shapefile):
                shp_union = "fy" + str((previous_year)) + "u.shp;" + "sfy" + str(current_year) + "dd.shp"
            else:
                shp_union = "fy" + str((previous_year)) + "u;" + "sfy" + str(current_year) + "dd"

        fyu = "fy" + str(current_year) + "u"
        if (debug): print "Processing Union: " + shp_union
        arcpy.Union_analysis(shp_union, fyu, "NO_FID", "1 meter", "GAPS")
        return fyu

    except:
        print 'Union failure: ' + fyu
        arcpy.AddMessage('Union failure: ' + fyu)
        sys.exit(0)

# ----------------------------------------------------------------------------
#   Multipart to Singlepart
# ----------------------------------------------------------------------------
def multi_to_single(datasrc, current_year):
    try:
        if (is_output_shapefile):
            final_layer = "fire" + str(current_year) + ".shp"
            datasource = datasrc + ".shp"
        else:
            final_layer = "fire" + str(current_year)
            datasource = datasrc

        if arcpy.Exists(final_layer):
            arcpy.Delete_management(final_layer)

        if (debug): print "Processing Multipart To Singlepart: " + final_layer
        arcpy.MultipartToSinglepart_management(datasource, final_layer)
        return ("fire" + str(current_year))

    except:
        print 'MultipartToSinglepart failure: ' + final_layer
        arcpy.AddMessage('MultipartToSinglepart failure: ' + final_layer)
        sys.exit(0)

# ----------------------------------------------------------------------------
#   Delete Temporary Layers
# ----------------------------------------------------------------------------
def cleanup(years_processed):
    try:
        for proc_year in years_processed:
            if (debug): print "Deleting temporary fire layers: " + str(proc_year)
			delvars = []
			delvars.append("fy%s" % proc_year)
			delvars.append("fy%sd" % proc_year)
			delvars.append("fy%su" % proc_year)
			delvars.append("sfy%s" % proc_year)
			delvars.append("sfy%sd" % proc_year)
			delvars.append("sfy%sdd" % proc_year)
			delvars.append("sfy%su" % proc_year)

            if (is_output_shapefile): # add the shapefile extension to the files to delete
				for index in range(len(delvars)):
					delvars[index] = "%s.shp" % delvars[index]
            
			
			for tvar in delvars:
				if arcpy.Exists(tvar):
					arcpy.Delete_management(tvar)
    except:
        print arcpy.AddMessage('Cleanup failure in year: ' + proc_year)
        #sys.exit(0)

# ----------------------------------------------------------------------------
#  Calculate:
#    ylb - 'year of last burn'
#    yslb - 'years since last burn'
#    nb - 'number of years burned'
#    CFRI - 'current fire return interval'
# ----------------------------------------------------------------------------
def calculate_fields(datasrc, current_year, years_processed, backdate_year):
    try:
        if (is_output_shapefile):
            datasource = datasrc + ".shp"
        else:
            datasource = datasrc

        if (debug): print "Calculating new fire fields: " + datasrc
        rows = arcpy.UpdateCursor(datasource)
        row = rows.next()
        while row:
            ylb = 0
            nb = 0
            for proc_year in years_processed:
                fld = "yr" + str(proc_year)
                try:
                    val = int(row.GetValue(fld))
                except:
                    arcpy.AddMessage("Failed to GetValue: " + fld)
                    sys.exit(0)

                if (val != 0):
                    if (val > ylb):
                        ylb = val
                    nb = nb + 1

            row.setValue("nb", nb)
            row.setValue("yslb", (current_year - ylb))
            row.setValue("ylb", ylb)
            row.setValue("CFRI", ((current_year - backdate_year)/(nb + 1)))
            rows.updateRow(row)
            row = rows.next()

        # remove the locks
        del row, rows

    except:
        del row, rows
        print arcpy.AddMessage('Cursor Calculations failure: ' + datasrc)
        sys.exit(0)

def populate_label(datasrc):
    try:
        if (is_output_shapefile):
            datasource = datasrc + ".shp"
        else:
            datasource = datasrc

        if (debug): print "Populating Label Field: " + datasrc
        rows = arcpy.UpdateCursor(datasource)
        row = rows.next()
        while row:
            year_val = str(row.getValue("ylb"))
            fld = "nm" + str(year_val)
            name_val = str(row.getValue(fld))
            row.setValue("label",name_val)
            rows.updateRow(row)
            row = rows.next()

        # remove the locks
        del row, rows

    except:
        del row, rows
        print arcpy.AddMessage('Label populating failure: ' + datasrc)
        sys.exit(0)

# ----------------------------------------------------------------------------
#   Main - Start program
# ----------------------------------------------------------------------------
timeStart = localtime()
if (debug): print "starting at " + strftime('%a, %d %b %Y %H:%M:%S %Z', timeStart)

try:
    fl_fires = setup_environment()
    min_year = get_min_year(input_fire_data)

    #max_year = get_max_year(input_fire_data)
    max_year = maximum_year
    prev_year = min_year - 1
    years_processed = []

    # allow to start in the middle of a predefined range if processing already completed
    # this fills the "years_processed" array with all previous year values and sets the
    # prev_year variable to correct value
    if (start_midway):
        for cur_year in range(min_year, continue_year):
            if is_fire_year(input_fire_data, cur_year):
                years_processed.append(cur_year)
                prev_year = cur_year
        min_year = continue_year


# Main Fire Year Loop

    for cur_year in range(min_year, max_year):
        if (debug): print "** Processing Year: " + str(cur_year) + " **"

# Only process years where there have been fires
        if is_fire_year(input_fire_data, cur_year):
            years_processed.append(cur_year)

# Select and Export current year fire perims
# sfy is the single year file
            sfy = get_temp_fire_year(fl_fires, cur_year)
            if (debug): print "finished export: " + sfy

# Union current year fire perims alone
# union it to itself to double the overlaps within a year
            sfyu = union_single(sfy, cur_year)
            if (debug): print "finished one year union" + str(cur_year)

# list fields in resulting file
##            list_fields(sfyu, "", "")
##            if (debug): print "listed field for " + str(cur_year)

# Create new field: FIRE_AREA
            add_field(sfyu, "FIRE_AREA", "double")

# Calculate FIRE_AREA
            calc_shape_area(sfyu)
            if (debug): print "finished calculate shape_area" + str(cur_year)

# Dissolve by FIRE_AREA
# this gets rid of the overlapping polygons within a year, we save the last fire name only
            sfyd = dissolve_single(sfyu, cur_year)
            if (debug): print "finished first dissolve (on shape area) to eliminate overlapping polygons in a single year: " + str(cur_year)

# Add current year fire name field
            nm_fld = "nm" + str(cur_year)
            add_field(sfyd, nm_fld, "text")
            if (debug): print "name field added for " + sfyd

# Fill fire name field
            fill_field(sfyd, nm_fld, "[LAST_FIRE_LABEL]", "VB")
            if (debug): print "name field filled for " + sfyd

# Dissolve by nm_fld
            dfield = nm_fld
            if (debug): print "dissolving by: " + dfield
            fyd = dissolve_layer(sfyd, dfield)
            if (debug): print "finished second dissolve: " + fyd

# Add year field
            yr_fld = "yr" + str(cur_year)
            add_field(fyd, yr_fld, "short")
            if (debug): print "year field added for " + fyd

# Fill year field
            fill_field(fyd, yr_fld, cur_year, "VB")
            if (debug): print "year field filled for " + fyd

# Repair Geometry
            repair_geometry(fyd)
            if (debug): print "finished repair geometry: " + fyd

# Union with previous year
            if (prev_year < minimum_year):
                fyu = union_fires(cur_year, prev_year, 1)
            else:
                fyu = union_fires(cur_year, prev_year, 0)
            if debug: print "finished union of current year and previous years: " + fyu

# Multipart to Singlepart
            fire_year_layer = multi_to_single(fyu, cur_year)
            if debug: print "finished multipart to singlepart: " + str(fire_year_layer)

# AddFields
            add_field(fire_year_layer, "ylb", "SHORT")      # year of last burn
            add_field(fire_year_layer, "yslb", "SHORT")     # years since last burn
            add_field(fire_year_layer, "nb", "SHORT")       # number of burns
            add_field(fire_year_layer, "CFRI", "SHORT")     # current fire return interval
            add_field(fire_year_layer, "meanRFRI", "SHORT") # mean reference FRI
            add_field(fire_year_layer, "minRFRI", "SHORT")  # minimum reference FRI
            add_field(fire_year_layer, "maxRFRI", "SHORT")  # maximum reference FRI
            add_field(fire_year_layer, "FRID", "float")     # fire return interval departure
            add_field(fire_year_layer, "FRIDCC", "text")   # fire return interval departure code
            if debug: print "added a bunch of fields: " + str(fire_year_layer)

# calculate ylb, yslb, nb, CFRI
            calculate_fields(fire_year_layer, cur_year, years_processed, backdate_year)
            if debug: print "calculated ylb, yslb, nb, CFRI: " + str(fire_year_layer)

# Add a label field and populate with the most recent fire name
            add_field(fire_year_layer, "label", "TEXT")
            if (debug): print "label field added to " + str(fire_year_layer)
            populate_label(fire_year_layer)
            if debug: print "populated label field: " + str(fire_year_layer)

            print "finished processing " + str(cur_year)

            prev_year = cur_year

    if not(debug):  cleanup(years_processed)
    print "Main() completed without exception"
except:
    for n in range(0,3):

        print arcpy.GetMessages(n)

del gp
if (debug): print "gp deleted"
timeEnd = localtime()
print '______________________________________________________________________'
print 'process started at: '+ strftime('%a, %d %b %Y %H:%M:%S %Z', timeStart)
print '  process ended at: '+ strftime('%a, %d %b %Y %H:%M:%S %Z', timeEnd)
